
# V개 이내의 노드를 E개의 간선으로 연결한 방향성 그래프에 대한 정보가 주어질 때, 특정한 두 개의 노드에 경로가 존재하는지 확인하는 프로그램을 만드시오.
# 두 개의 노드에 대해 경로가 있으면 1, 없으면 0을 출력한다.
# 예를 들어 다음과 같은 그래프에서 1에서 6으로 가는 경로를 찾는 경우, 경로가 존재하므로 1을 출력한다.
# 노드번호는 1번부터 존재하며, V개의 노드 중에는 간선으로 연결되지 않은 경우도 있을 수 있다.

# [입력]
# 첫 줄에 테스트 케이스 개수 T가 주어진다.  1≤T≤50
# 다음 줄부터 테스트 케이스의 첫 줄에 V와 E가 주어진다. 5≤V≤50, 4≤E≤1000
# 테스트케이스의 둘째 줄부터 E개의 줄에 걸쳐, 출발 도착 노드로 간선 정보가 주어진다.
# E개의 줄 이후에는 경로의 존재를 확인할 출발 노드 S와 도착노드 G가 주어진다.

# [출력]
# 각 줄마다 "#T" (T는 테스트 케이스 번호)를 출력한 뒤, 답을 출력한다.

import sys
sys.stdin = open('230214 4일차-그래프 경로.txt', 'r')

# [문제풀이]
# 0. V개 이내의 노드를 E개의 간선으로 연결.
# 0-1. 방향이 존재하는 그래프로서 1개 또는 2개의 경로를 가지고 있다.
# 0-2. 다만 방향성에 의해 이어져도 활용을 할 수 가 없는 경우도 있다.
# 1. 테스트 케이스 이후
# 1-1. 노드의 갯수 V와 간선 E개가 주어진다.
# 1-2. 이어서 각 노드가 연결된 간선에 대해서 주어진다.(총 E줄로 주어짐)
# 1-3. 마지막으로 출발지점과, 도착지점이 나오게 되면서 출발지점에서 도착지점까지 갈 수 있다면 1을, 없다면 0을 출력하면 된다.
# 2. 0-1.과 1-2.에 따라서 '인접행렬'작성간 [i][j] =1, [j][i]=1이 아닌 [i][j] =1 이것만이 가능하겠다.
# 3. 그 외는 기존 DFS 풀이법과 같다.


T = int(input())
for testcase in range(1, T+1):
    # 입력값 받기
    V, E = map(int, input().split())
    adj_matrix = [[0]*(V+1) for _ in range(V+1)]                # 0~V만큼의 행렬을 만든다.
    for _ in range(E):                                          # E만큼 입력값을 받아야 하므로 반복
        i, j = map(int, input().split())                        # 노드 간선의 출발지(i)와 도착지(j)를받음
        adj_matrix[i][j] = 1                                    # 방향성 있는 간선이므로 [i][j]에만 1값을 작성
    S, G = map(int, input().split())                            # S와 G를 입력
    
    # 찾기 시작
    def find_arrive(start, goal):                               # 시작점과 도착지점을 매개변수로 하는 find_arrive 함수 제작
        stack = []                                              # 현재 위치를 받기 위한 stack. 내가 b 위치로 가면 기존 값을 뺀 후 b 위치의 값을 넣어줌.
        visited = [0]*(V+1)                                     # 방문여부를 확인하기 위한 visited 리스트
        stack.append(start)                                     # 시작지점을 stack에 추가
        visited[start] = 1                                      # start의 위치를 1로 함으로서 해당 수에 방문했음을 확인 가능
        current = stack[-1]

        while stack:                                            # 스택이 비어있지 않으면, 그러니까 갈 경로가 있는 상태면
            current = stack[-1]
            for i in range(1, V+1):                             # 노드 번호가 1~ V까지 이므로 i인자도 1~V로 반복문실행
                if adj_matrix[current][i] and not visited[i]:   # 현재 경로와 i가 연결되있으면서 i에 들려보지 않았다면
                    stack.append(i)                             # stack에 i 넣기, 여기서 stack.pop() 안하는 이유는 값이 없으면 되돌아가야하니까.
                    visited[i] = 1                              # 방문한 숫자에 해당하는 곳에 1을 넣어준다.
                    if visited[goal] == 1:                      # 만약 방금 방문한 목표로하는 도착지였다면
                        return f'#{testcase} {1}'               # 함수를 종료하고 출력값을 제시하자.
                    break                                       # 여러 값이 있어도 하나만 찾아서 먼저 따라가면 되는 거니까
            else:                                               # i가 다 방문하거나 더 이상의 경로가 없으면
                stack.pop()                                     # 현재위치도 이제 빼고 끝내자.
        return f'#{testcase} {0}'                               # 중간에 return이 없다는 것은 찾아도찾아도 없다는 뜻이니. 함수를 종료하고 출력값을 제시하자.
    print(find_arrive(S, G))