# 평소에 잔머리가 발달하고 게으른 철수는 비밀번호를 기억하는 것이 너무 귀찮았습니다.
# 적어서 가지고 다니고 싶지만 누가 볼까봐 걱정입니다. 한가지 생각을 해냅니다.
# 0~9로 이루어진 번호 문자열에서 같은 번호로 붙어있는 쌍들을 소거하고 남은 번호를 비밀번호로 만드는 것입니다.
# 번호 쌍이 소거되고 소거된 번호 쌍의 좌우 번호가 같은 번호이면 또 소거 할 수 있습니다.
# 예를 들어 아래의 번호 열을 철수의 방법으로 소거하고 알아낸 비밀 번호입니다.

# [입력]
# 10개의 테스트 케이스가 10줄에 걸쳐, 한 줄에 테스트 케이스 하나씩 제공된다.
# 각 테스트 케이스는 우선 문자열이 포함하는 문자의 총 수가 주어지고, 공백을 둔 다음 번호 문자열이 공백 없이 제공된다.
# 문자열은 0~9로 구성되며 문자열의 길이 N은 10≤N≤100이다. 비밀번호의 길이는 문자열의 길이보다 작다.
 
# [출력]
# #부호와 함께 테스트 케이스의 번호를 출력하고, 공백 문자 후 테스트 케이스에 대한 답(비밀번호)을 출력한다.

import sys
sys.stdin = open('230213 10일차-비밀번호.txt', 'r')
# [문제풀이]
# 0. 반복되는 수를 제거하는 방식이다.
# 0-1. 붙어있는 수를 제거한 후 앞의 수와 뒤의수를 이어주고
# 0-2. 완료되면또 검사해서 해당시 0-1을 해준다.
# 0-3. 더 이상 반복되는 수가 없다면 남은 숫자를 이어서 비밀번호로 만들어 출력해준다.
# 1. 스택을 이용해보자.

T = 10
for testcase in range(1, T+1):
    N, string = map(str, input().split())               # 문자열의 길이 N과 숫자로 이루어진 문자열 받기
    N = int(N)                                          # 문자열로 받은 N을 숫자로 바꿔주기
    string = list(map(int, string))                     # 문자열을 숫자로 만들어 각 숫자별로 분리해서 리스트만들기
    stack = [0]*(N+1)                                   # 스택을 이용하기 위해 만든 stack
    top = -1                                            # 스택을 이용하기 위해 생성한 top 변수

    for i in range(N):                                  # N만큼 반복 실행
        if i == 0:                                      # stack에 첫 값을 넣기 위한 if
            top += 1
            stack[top] = string[i]                      # stack[0] = string[0]과 동일함
        else:                                           # i != 0이면
            top += 1                                    # 우선 top +1 해주고, stack[top]에 값을 넣어준다.
            stack[top] = string[i]
            if stack[top] == stack[top-1] and top > 0:  # 반복값이면
                top -= 2                                # 스택에서 사용하는 top를 -2해준다.
    
    # 출력하기
    print(f'#{testcase}', end=' ')                      # 테스트케이스 출력
    for pass_num in range(top+1):                       # [0] ~ [top]까지 출력해야되므로
        print(stack[pass_num], end='')                  # 출력값 출력
    print()                                             # 테스트케이스가 여럿이므로 end에 따라 이어지지 않도록 하기 위함