

# 그림과 같이 도식화한 지도에서 A도시에서 출발하여 B도시로 가는 길이 존재하는지 조사하려고 한다.
# 길 중간 중간에는 최대 2개의 갈림길이 존재하고, 모든 길은 일방 통행으로 되돌아오는 것이 불가능하다.
# 다음과 같이 길이 주어질 때, A도시에서 B도시로 가는 길이 존재하는지 알아내는 프로그램을 작성하여라.
#  - A와 B는 숫자 0과 99으로 고정된다.
#  - 모든 길은 순서쌍으로 나타내어진다. 위 예시에서 2번에서 출발 할 수 있는 길의 표현은 (2, 5), (2, 9)로 나타낼 수 있다.
#  - 가는 길의 개수와 상관없이 한가지 길이라도 존재한다면 길이 존재하는 것이다.
#  - 단 화살표 방향을 거슬러 돌아갈 수는 없다.

#  [제약 사항]
# 출발점은 0, 도착점은 99으로 표현된다.
# 정점(분기점)의 개수는 98개(출발점과 도착점 제외)를 넘어가지 않으며, 한 개의 정점에서 선택할 수 있는 길의 개수도 2개를 넘어가지 않는다.
# 아래 제시된 가이드 라인은 제안사항일 뿐 강제사항은 아니다.

# [데이터 저장 가이드]
# 정점(분기점)의 개수가 최대 100개 이기 때문에, size [100]의 정적 배열 2개을 선언하여, 각 정점의 번호를 주소로 사용하고, 저장되는 데이터는 각 정점에서 도착하는 정점의 번호를 저장한다.
# 위 그림을 저장하였을 때 결과는 다음과 같다.
 
# 0 1 2 3 4 5 6  7 8 9 10 99
# 1 3 5 7 8 6 10 9   8

# 0 1 2 3 4 5 6 7  8 9  10 99
# 2 4 9     7   99   10



# [입력]
# 각 테스트 케이스의 첫 줄에는 테스트 케이스의 번호와 길의 총 개수가 주어지고 그 다음 줄에는 순서쌍이 주어진다.
# 순서쌍의 경우, 별도로 나누어 표현되는 것이 아니라 숫자의 나열이며, 나열된 순서대로 순서쌍을 이룬다.

# [출력]
# #부호와 함께 테스트 케이스의 번호를 출력하고, 공백 문자 후 테스트 케이스에 대한 답을 출력한다.

import sys
sys.stdin = open('230214 4일차-길찾기.txt', 'r')

# [문제풀이]
# 0. 최대 2개의 갈림길이므로 2진 트리이다.
# 0-1. 방향이 있는 그래프이다. 
# 0-2. 고정으로 출발점은 0, 도착점은 99이므로 총 100개이다. 분기점은 0과 99를 제외한 총 98개 되겠다.
# 1. 입력받는 값은 테스트케이스의 번화, 길의 총 갯수(N이라 명명)
# 2. 경로에 대해서는 (ㅌ,ㅌ)의 식으로 2개씩 입력받을 수 있도록 만들면 된다.
# 3. 그리고 해당 경로를 인접행렬로 만들어서 추가하도록 하자. 방향이 있으므로 [i][j] = 1만 행동한다.

# def is_can_go(start, goal):
#     stack = []                                                      # 스택을 활용해 값을 넣고, 길을 되돌아가는 식을 만들기 위해
#     visited = [0]*100                                               # 0~99까지 값 중에서 방문을 했다면 기록하기 위해서
#     stack.append(start)                                             # 길찾기를 시작하기 전에 스택에 위치를 넣는다.
#     visited[start] = 1                                              # 0~99로 되어있으며, 0이 출발, 99가 도착이므로 그대로 인덱스로 활용 가능하다.
#     curret = stack[-1]                                              # 현재 위치를 stack을 이용했으므로 stack의 맨 마지막 값을 현재위치로 명명

#     while stack :                                                   # 스택에 값이 있으면
#         current = stack[-1]                                         # 반복문이 돌면서 바뀔 수 있는 현재 위치를 재정의
#         for i in range(100):                                        # 0~99번 노드를 확인할 것임
#             if adj_matrix[current][i] and not visited[i]:           # 현재에서 i로 가는 경로가 있고, 해당 경로로 방문하지 않았다면
#                 stack.append(i)                                     # stack에 경로의 도착점을 추가해서 현재위치 표기(왜냐 도착했으니까)
#                 visited[i] = 1                                      # 경로의 도착점인 i지점에 방문했음을 표시.
#                 if i == goal:                                       # 만약 i가 goal(목표 도착지)와 같다면
#                     return f'#{testcase} {1}'                       # 함수를 종결하고 출력값을 반환
#                 break
#         else:                                                       # 더 갈 수 있는 길이 없어 막혔으면,
#             stack.pop()                                             # 스택값 반환하고, 이전 도착지로 되돌아가기
#     return f'#{testcase} {0}'                                       # 함수를 종결하고 출력값을 반환


# T =10
# for testcase in range(1,T+1):
#     adj_matrix = [[0]*100 for _ in range(100)]                      # 0~99까지의 행렬을 만듬. 0~100으로 1~100을 사용하고 싶었으나 문제에서 0을 사용하므로 0~99로 제작
#     testcase, N = map(int, input().split())                         # 테스트케이스 경로 갯수 N을 받음
#     initial_input = list(map(int, input().split()))                 # 경로를 사용하기위해 리스트에 날것으로 받는 변수
#     for i in range(0, len(initial_input), 2):                       # 날것으로 받은 경로를 가공
#         adj_matrix[initial_input[i]][initial_input[i+1]] = 1        # adj_matrix에 기입
#     print(is_can_go(0, 99))                                         # 0에서 99로 갈 수 있는지 확인하는 변수로 출력값 출력.



def is_can_go(start, goal):
    stack = [0]*101                                                 # 0~100까지들어있는 리스트로 스택을 만듬. 마지막 100은 혹시 생길 오류 방지
    visited = [0]*100                                               # 방문한 위치 확인하기 위한 리스트
    top = -1                                                        # top을 이용하여 스택을 사용하기 위함
    top += 1                                                        # 값이 들어가니 top에 +1 해서 해당 값을 가리키도록 함
    visited[start] = 1                                              # 0이 시작위치이며, visited리스트에 방문한 위치는 1로 변환할 것임것임
    current = stack[top]                                            # 현재 위치는 stack의 top이 가리키는 값임

    while -1 < top <= 99:                                           # top이 활동하는 곳은 0~99이다. -1이 되면 모든 값을 다 돈 것이 되므로.
        current = stack[top]                                        # while문으로 반복되면서 현재위치를 재정의
        for i in range(100):
            if adj_matrix[current][i] and not visited[i]:           # 현재 위치에서 i로 가는 경로가 있고, 방문하지 않았다면
                top+=1                                              # top +1해주고
                stack[top] = i                                      # top이 가리키는 stack의 위치에 i를 넣어준다.
                visited[i] = 1                                      # i는 방문한 위치로 표기
                if i == goal:                                       # i가 목표지라면
                    return f'#{testcase} {1}'                       # 함수를 중단하고 출력값 출력
                break                                               # 가능한 경로를 찾았으니 for문을 탈출
        else:                                                       # 더 갈 수 있는 길이 없다면(for-else)
            top -=1                                                 # top의 위치를 조절해서 해당위치의 stack값으로 움직인다.
    return f'#{testcase} {0}'


T =10
for testcase in range(1,T+1):
    adj_matrix = [[0]*100 for _ in range(100)]                      # 0~99까지의 행렬을 만듬. 0~100으로 1~100을 사용하고 싶었으나 문제에서 0을 사용하므로 0~99로 제작
    testcase, N = map(int, input().split())                         # 테스트케이스 경로 갯수 N을 받음
    initial_input = list(map(int, input().split()))                 # 경로를 사용하기위해 리스트에 날것으로 받는 변수
    for i in range(0, len(initial_input), 2):                       # 날것으로 받은 경로를 가공
        adj_matrix[initial_input[i]][initial_input[i+1]] = 1        # adj_matrix에 기입
    print(is_can_go(0, 99))                                         # 0에서 99로 갈 수 있는지 확인하는 변수로 출력값 출력.