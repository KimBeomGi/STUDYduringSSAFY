
# [문제]
# 완전 이진 트리의 리프 노드에 1000이하의 자연수가 저장되어 있고, 리프 노드를 제외한 노드에는 자식 노드에 저장된 값의 합이 들어있다고 한다.
# 다음은 리프 노드에 저장된 1, 2, 3이 주어졌을 때, 나머지 노드에 자식 노드의 합을 저장한 예이다.
# N개의 노드를 갖는 완전 이진 트리의 노드 번호는 루트가 1번이 되며, 같은 단계에서는 왼쪽에서 오른쪽으로 증가, 단계가 꽉 차면 다음단계의 왼쪽부터 시작된다.
# 완전 이진 트리의 특성상 1번부터 N번까지 빠지는 노드 번호는 없다.
# 리프 노드의 번호와 저장된 값이 주어지면 나머지 노드에 자식 노드 값의 합을 저장한 다음, 지정한 노드 번호에 저장된 값을 출력하는 프로그램을 작성 하시오.

# [입력]
# 첫 줄에 테스트케이스의 수 T가 주어진다. 1<=T<=50
# 다음 줄부터 테스트 케이스의 별로 노드의 개수 N과 리프 노드의 개수 M, 값을 출력할 노드 번호 L이 주어지고, 다음 줄부터 M개의 줄에 걸쳐 리프 노드 번호와 1000이하의 자연수가 주어진다.

# [출력]
# 각 줄마다 "#T" (T는 테스트 케이스 번호)를 출력한 뒤, 답을 출력한다.

import sys
sys.stdin = open('230223 8일차-노드의 합.txt','r')

# [문제풀이]
# 0. 주어지는 리프 노드 값을 이용해서 주어진 노드를 완성시키고, 그에 따라 출력하라고 정한 노드의 값을 출력하는 것이다.
# 0-1. 노드의 개수 N, 리프노드의 개수M, 값을 출력할 노드 번호 L이 입력값으로 주어진다. 그런다음 리프노드 번호와 함께 값이 주어진다.
# 1. 해당 문제는 후위 순회를 이용해서 왼쪽자식 노드와 오른쪽 자식노드의 합이 번호에 입력되도록 하면 되는 것이다.

#후위 연산으로 좌우자식을 합해 부모의 값으로 만드는 함수 생성
def gen_postorder(A):
    if A > N//2:                                # GKDTKD
        return
    gen_postorder(A*2)                          # 왼쪽자식의 값
    gen_postorder(A*2+1)                        # 오른쪽 자식의 값
    try:                                        # 시도해보자.
        tree[A] = tree[A*2] + tree[A*2+1]       # 부모값은 왼쪽자식값과 오른쪽 자식값
    except:                                     # 시도가 안되면 이걸해보자.
        tree[A] = tree[A*2]                     # 왼쪽 자식값이 자기 값.
    return

T = int(input())
for testcase in range(1, T+1):
    N, M, L = map(int, input().split())         # 노드 갯수, N, 리프노드 갯수 M, 출력할 노드번호 L을 받음
    
    # 리프노드 생성. 각 노드의 번호는 인덱스로 설정하고, 해당 노드의 값은 리스트의 요소가 되게 작성하자.   
    tree = [0]*(N+1)                            # 행 1개만 있으면 이 문제에서는 가능하다.
    for i in range(M):                          # 리프노드 작성
        node_num, node_value = map(int, input().split())    # 노드 번호와 노드 값을 입력받기.
        tree[node_num] = node_value             # 해당노드에 해당 노드 값을 입력시킴
    gen_postorder(1)                            # 1번노드를 root로 하는 트리에서 함수 실행
    # print(tree)
    print(f'#{testcase} {tree[L]}')