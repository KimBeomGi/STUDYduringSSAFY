import sys
sys.stdin = open('파이썬 sw문제해결 기본-stack1 8차시 4일차-그래프 경로.txt', 'r')

# V개 이내의 노드를 E개의 간선으로 연결한 방향성 그래프에 대한 정보가 주어질 때, 특정한 두 개의 노드에 경로가 존재하는지 확인하는 프로그램을 만드시오.
# 두 개의 노드에 대해 경로가 있으면 1, 없으면 0을 출력한다.
# 예를 들어 다음과 같은 그래프에서 1에서 6으로 가는 경로를 찾는 경우, 경로가 존재하므로 1을 출력한다.
# 노드번호는 1번부터 존재하며, V개의 노드 중에는 간선으로 연결되지 않은 경우도 있을 수 있다.

# [입력]
# 첫 줄에 테스트 케이스 개수 T가 주어진다.  1≤T≤50
# 다음 줄부터 테스트 케이스의 첫 줄에 V와 E가 주어진다. 5≤V≤50, 4≤E≤1000
# 테스트케이스의 둘째 줄부터 E개의 줄에 걸쳐, 출발 도착 노드로 간선 정보가 주어진다.
# E개의 줄 이후에는 경로의 존재를 확인할 출발 노드 S와 도착노드 G가 주어진다.

# [출력]
# 각 줄마다 "#T" (T는 테스트 케이스 번호)를 출력한 뒤, 답을 출력한다.

# [문제풀이]
# 0. 출발지와 도착지가 주어지면 해당 출발지로 갈 수 있는지를 확인해야한다.
# 1. 주어진 문제는 경로가 있지만 방향이 있는 경로이므로 해당 부분을 확인할 수 있게 해줘야한다.
# 2. 인접행렬을 이용하고, 또, stack을 이용해서 풀어보도록 하자.
# 3. 인접행렬을 이용함에 있어 다음 경로로 길이 막히거나, 경로는 다 돌아봤는데도 없다면,
# 3-1. 스택의 값을 제거함(top-1) 함으로 돌아가서 다른 경로를 찾아보도록 하자.
# 4. visited 변수를 생성해서 들렸는지 안들렸는지도 확인하는 행위를 같이 진행해서 무한반복 등을 방지하자.

def is_can(adj_matrix, V, E, S, G):
    # 추가 변수 생성
    stack = [0]*(E+1)                               # stack을 생성, 크기는 간선의 갯수+1만큼(오류방지를 위해)
    top = -1                                        # top은 -1로 초기화
    visited = [0]*(V+1)                             # 해당 번호를 방문여부를 확인하기 위한 visited 변수 숫자가 1부터 시작해서 보기편하게 하기 위해 v+1

    # 출발지에서 도착지까지 가능 여부 확인
    top += 1                                        # top을 한 칸 올림
    stack[top] = S                                  # stack에 출발 번호를 기입
    visited[S] = 1                                  # 출발번호 지점을 들린 것으로 하여 1로 변경
    while top > -1:                                 # 스택에 활용한 값이 있을 때만 반복
        for i in range(V+1):                        # 출발지에서 가능한 모든 도착지를 찾기 위해서
            if i == G and adj_matrix[stack[top]][i] == 1:                   # 만약 도착지값이 현재 지점에서 출발해서 도착 가능하다면
                return f'#{testcase} 1'             # 출발지에서 도착지에 출발 및 도착이 가능하다는 출력값을 출력
            
            elif visited[i] != 1 and adj_matrix[stack[top]][i] == 1:        # stack[top]의 값에서 출발해서 도착하는 경로가 있는지 확인해서 있다면
                top += 1                            # top을 한 칸 올리고
                stack[top] = i                      # i를 스택에 입력하고, 다시 출발지가 되는지 확인해야지
                visited[i] = 1                      # 방문기록에도 표시하기
                break                               # for 반복문을 중단시키고 while문으로 돌아감
        else:                                       # 갈 길이 없으므로
            top -= 1                                # 탑을 한칸 내림
    
    return f'#{testcase} 0'                         # 다 뒤져도 값이 없음을 의미하므로 없음을 출력

T= int(input())
for testcase in range(1, T+1):
    # 입력값 받기
    V, E = map(int, input().split())                # 노드의 갯수 V, 간선의 갯수 E
    adj_matrix = [[0]*(V+1) for _ in range(V+1)]    # V+1을 한 이유는 노드 번호가 0부터가 아닌 1부터 시작하므로 보기 편하기 위해
    for _ in range(E):                              # 간선의 갯수만큼 입력받기
        a, b = map(int, input().split())            # 간선의 출발지점과 도착지점
        adj_matrix[a][b] = 1                        # 출발지점을 행 도착지점을 열로 해서 adj_matrix에 입력
    S, G = map(int, input().split())                # 출발지 번호 S, 도착지 번호 G
    print(is_can(adj_matrix, V, E, S, G))