'''
# 참고
arr = [
    [1,2,3,4,5],
    [1,2,3,4,5],
    [1,2,3,4,5],
    [1,2,3,4,5],
    [1,2,3,4,5]
]
N = 5
r,c = 0,0
while r < 5:
    print(arr[r][c])
    if r == 2:
        while True:
            if arr[r][c] == 3:
                break
            print(arr[r][c])
            c += 1
    r += 1
print('끝')
'''

# 계속 반복문 돌리고 이동이동이동
# 델타써도되고 굳이 안써도 되고 뭐 각자 알아서 하고
# 왼쪽 아래 오른쪽 아래 뭐 기타 등등

# [문제]
# 점심 시간에 산책을 다니는 사원들은 최근 날씨가 더워져, 사다리 게임을 통하여 누가 아이스크림을 구입할지 결정하기로 한다.
# 김 대리는 사다리타기에 참여하지 않는 대신 사다리를 그리기로 하였다.
# 사다리를 다 그리고 보니 김 대리는 어느 사다리를 고르면 X표시에 도착하게 되는지 궁금해졌다. 이를 구해보자.
# 아래 <그림 1>의 예를 살펴보면, 출발점 x=0 및 x=9인 세로 방향의 두 막대 사이에 임의의 개수의 막대들이 랜덤 간격으로 추가되고(이 예에서는 2개가 추가됨) 이 막대들 사이에 가로 방향의 선들이 또한 랜덤하게 연결된다.
# X=0인 출발점에서 출발하는 사례에 대해서 화살표로 표시한 바와 같이, 아래 방향으로 진행하면서 좌우 방향으로 이동 가능한 통로가 나타나면 방향 전환을 하게 된다.
# 방향 전환 이후엔 다시 아래 방향으로만 이동하게 되며, 바닥에 도착하면 멈추게 된다.
# 문제의 X표시에 도착하려면 X=4인 출발점에서 출발해야 하므로 답은 4가 된다. 해당 경로는 별도로 표시하였다.
 
#아래 <그림 2>와 같은 100 x 100 크기의 2차원 배열로 주어진 사다리에 대해서, 지정된 도착점에 대응되는 출발점 X를 반환하는 코드를 작성하라
# (‘0’으로 채워진 평면상에 사다리는 연속된 ‘1’로 표현된다. 도착 지점은 '2'로 표현된다).

# [제약 사항]
# 한 막대에서 출발한 가로선이 다른 막대를 가로질러서 연속하여 이어지는 경우는 없다.

# [입력]
# 입력 파일의 첫 번째 줄에는 테스트 케이스의 번호가 주어지며, 바로 다음 줄에 테스트 케이스가 주어진다.
# 총 10개의 테스트 케이스가 주어진다.

# [출력]
# #부호와 함께 테스트 케이스의 번호를 출력하고, 공백 문자 후 도착하게 되는 출발점의 x좌표를 출력한다.


import sys
sys.stdin = open('ladder1_input.txt', "r")

# [문제풀이]
# 0. 이동하는 부분은 1로 표시되어있으며 이를 이용해 흔한 사다리게임을 구현한다.
# 0-1. 10개의 테스트 케이스가 주어지는데, #t X좌표 식으로 도착점에 도착하는 출발점 X좌표를 출력해야한다.
# 0-2. 사다리는 100 by 100 크기의 행렬 구조이며, 이때 x 좌표는 행렬[리스트][좌표]가 된다.
# 0-3. 따라서 각 행 인 리스트는 y좌표, 열 인 리스트[a]는 x좌표 이다.
# 0-4. matrix[y좌표][x좌표]
# 1. 행렬[0][0]~행렬[99][99] 이 존재한다.
# 1-1. 2가지 방법을 먼저 생각해볼 수 있다.
# 1-2. 1번째로 반복문을 이용해 첫 리스트에서 1이 있으면 조건에 따라 사다리타기를 실시해 도착값이 2인 곳의 출발지의 값을 출력하는 방법
# 1-3. 2번째로 조건을 역이용해 마지막 리스트에서 도착 값인 2가 있는 곳에서부터 시작해서 출발지에 도착해서 출발지의 값을 출력하는 방법
# 2. 1-3의 방법으로 문제풀이 시작

T = 10
for testcase in range(1,T+1):                                                   # 테스트케이스 반복
    tc = int(input())                                                           # 처음 입력으로 테스트케이스가 나와서 받음
    ladder_matrix = [list(map(int,input().split())) for _ in range(100)]        # 100 by 100의 행렬이므로 range(100)으로 총 100개의 리스트를 입력
    
    # 도착지에서 거슬러 올라가는 방법 이용
    for arrive_x in range(100):                                                 # 총 100개의 x값 중
        if ladder_matrix[99][arrive_x] == 2:                                    # 마지막 행(도착행)의 x값이 2(도착지)라면
            now_y = 99                                                          # 마지막 행이므로 y값은 99
            now_x = arrive_x                                                    # 2가 있는 위치이므로 x값은 x
            
            # 각 1을 따라 움직이면 된다. 언제끝날지 모르므로 while 반복문 이용
            # 왼쪽 또는 오른쪽으로 옮겨간 후에 계속 이동하고 올라가야하는데 그걸 안했다.
            # now_x가 맨 왼쪽에 붙어버릴 경우 now_x-1 = -1이 되면서 ladder_matrix[now_y][-1]이 되어버리는 경우를 다시 고려.
            # now_x가 맨 오른쪽에 붙어버릴 경우 now_x+1 이 99를 넘어가면서 리스트 범위 벗어남 오류가 발생하니 이런 경우 고려.

            while 0 <= now_y <= 99 or 0 <= now_x <= 99:                         # while문이 정상작동하기위한 조건으로 현재 위치가 각 행과 열에 위치할때 작동해라.
                if now_y == 0:                                                  # 도착지점을 모두 돌고나서 1행의 출발지점에 왔을 경우
                    print(f'#{testcase} {now_x}')
                    break
                # 올라갈때 사용할 if 문의 순서 중요. 올라가는 것 먼저 해버리면 사다리 작동 오류남.

                # 왼쪽으로 이동
                elif now_x >= 1 and ladder_matrix[now_y][now_x-1] == 1:         # 올라가는 사다리의 왼쪽에 사다리(1)이 있다면, 동시에 현재 x 좌표가 1 이상일 때.
                    while ladder_matrix[now_y][now_x] > 0:                      # 사다리 위에 있을때 동안 반복문 진행
                        now_x = now_x - 1                                       # 현재 x 좌표를 왼쪽으로 옮김
                        if now_x == 0 or ladder_matrix[now_y][now_x-1] == 0:    # 현재 x 좌표가 0(왼쪽 끝 값)이 되거나 더 왼쪽으로 가면 사다리가 없게 될 시에는
                            now_y = now_y - 1                                   # 현재 y 좌표를 위쪽으로 옮김
                            break
                        # elif ladder_matrix[now_y][now_x-1] == 0:                # 더 왼쪽으로 가면 사다리가 없게 될 시에는
                        #     now_y = now_y - 1                                   # 현재 y 좌표를 위쪽으로 옮김
                        #     break                                               # 왼쪽으로 가는 while문에서 빠져나옴

                # 오른쪽으로 이동
                elif now_x <= 98 and ladder_matrix[now_y][now_x+1] == 1:        # 올라가는 사다리의 오른쪽에 사다리(1)이 있다면, 동시에 현재 x 좌표가 98 이하일 때,
                    while ladder_matrix[now_y][now_x] > 0:                      # 사다리 위에 있을때 동안 반복문 진행
                        now_x = now_x + 1                                       # 현재 x 좌표를 오른쪽으로 옮김
                        if now_x == 99 or ladder_matrix[now_y][now_x+1] == 0:   # 현재 x 좌표가 99(오른쪽 끝 값)가 되거나 더 오른쪽으로 가면 사다리가 없게 될 시에는
                            now_y = now_y - 1                                   # 현재 y 좌표를 위쪽으로 옮김
                            break
                        # elif ladder_matrix[now_y][now_x+1] == 0:                # 더 오른쪽으로 가면 사다리가 없게 될 시에는
                        #     now_y = now_y - 1                                   # 현재 y 좌표를 위쪽으로 옮김
                        #     break                                               # 왼쪽으로 가는 while문에서 빠져나옴
                
                # 위쪽으로 이동
                elif ladder_matrix[now_y-1][now_x] == 1:                        # 올라가는 사다리의 위쪽에 사다리(1)가 있다면
                    now_y = now_y - 1                                           # 현재 y 좌표를 위쪽으로 옮김