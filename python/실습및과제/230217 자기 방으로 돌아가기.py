

# [문제]
# 고등학교 학생들이 학교에서 수련회를 갔다. 수련회에 간 학생들은 친구들과 음주가무를 즐기다가 밤 12시가 되자 조교들의 눈을 피해 자기방으로 돌아가려고 한다.
# 제 시간에 자기방으로 돌아가지 못한 학생이 한 명이라도 발견되면 큰일나기 때문에 최단 시간에 모든 학생이 자신의 방으로 돌아가려고 한다.
# 숙소는 긴 복도를 따라 총 400개의 방이 다음과 같이 배열되어 있다.

# 모든 학생들은 현재 위치에서 자신의 방으로 돌아가려고 하는데, 만약 두 학생이 자기방으로 돌아가면서 지나는 복도의 구간이 겹치면 두 학생은 동시에 돌아갈 수 없다.
# 예를 들어 (방1 -> 4) 와 (방3 -> 6) 은 복도 구간이 겹치므로 한 사람은 기다렸다가 다음 차례에 이동해야 한다. 이동하는 데에는 거리에 관계없이 단위 시간이 걸린다고 하자.
# 각 학생들의 현재 방 위치와 돌아가야 할 방의 위치의 목록이 주어질 때, 최소 몇 단위시간만에 모든 학생들이 이동할 수 있는지를 구하시오.

# [입력]
# 입력은 T(≤10)개의 테스트 케이스로 되어 있다. 각 테스트 케이스의 첫 줄에는 돌아가야 할 학생들의 수 N이 주어진다.
# 다음 N 줄에는 각 학생의 현재 방 번호(≤400)와 돌아가야 할 방의 번호(≤400)가 주어진다. 주어지는 2N개의 방 번호 중 중복되는 것은 없다.

# [출력]
# 테스트 케이스 T에 대한 결과는 “#T ”을 찍고, 각 테스트 케이스마다 필요한 시간을 한 줄에 하나씩 출력한다.

import sys
sys.stdin = open('230217 자기 방으로 돌아가기.txt', 'r')

# [문제풀이]
# 0. 400개의 방이 다음과 같이 배열되어 있으므로 고정.
# 0-1. 복도를 기준으로 위에는 1,3,5,,, 399.까지의 홀수방, 아래는 2,4,6,8,,,, 400. 까지의 짝수방이 놓여져있다.
# 0-2. 학생이 겹치면 갈 수가 없으니 한 학생씩 먼저 가야한다.
# 0-3. 칸으로 계산해서 칸이 겹치면 그게 겹치는 거니까 알아두자. 거리에 관계없이 단위시간이 걸리므로, 1 -> 400으로 가도 1초이다.
# 1. 학생들이 여럿이 간다해도 한번에 겹치지만 않으면 1초가 걸릴 수도 있다.
# 2. 만약 한 구간에 겹치는 학생이 2명이 있다면 2초, 3명이 있다며 3초가 걸린다.
# 2-1. 따라서 2.에 따라 고려해야할 요소는 최대 몇명이 한 구간에 겹치는 가를 보면된다.
# 3. 만약에 1-200, 100-300, 200-250, 249- 301과 같으면?
# 3-1 .만약 1-200. 211-11이 있다면?
# 3-2. 1~10 11~20 이런 구간에 겹치는 최대수가 아닌 [1]또는 [11]과 같이 한 곳에 겹치는 최대 구간을 확인해야한다.
# 3-3. 그리고 1-200과 같은 겉이 아닌, 200-0과 같은 것이 있다면 계산식에서 오차가 생길 수 있으니
# 3-3-1. 동일하게 1-200 으로 바꿔주도록 하자
# 4. 따라서 총 400개 이므로 [0]*400으로 만들어주고 1-200이라면 각 인덱스 [0], [1],[2],,,[200]에 해당하는 곳에 +1을 해주자.
# 4-1. 그런데 복도를 중앙에 공유하고 있으므로 복도에 있는 공간은 총 200 [0]*200으로 만들어주면된다.
# 4-2. 만약 가는 지점이 홀수-짝수라면 짝수-1을 해서 걸치는 공간을 계산 해주도록하자.

T = int(input())
for testcase in range(1, T+1):
    hallway = [0]*200                               # 각 방앞의 구간을 나타내는 복도 변수 hallway. 총 200개의 구간이 있음
    N = int(input())                                # 돌아가야할 학생들의 수 N
    for i in range(N):                              # N 횟수 만큼 입력값 받음
        go, arrive = map(int, input().split())      # 출발과 도착의 변수를 각각 입력받음
        if go % 2 == 0:                             # go가 짝수 방이면
            go = go -1                              # go-1을 해주기
        if arrive % 2 == 0:                         # arrive가 짝수방이면
            arrive = arrive - 1                     # arrive-1 해주기
        if go > arrive:                             # go가 arrive 보다 방번호가 크면
            go, arrive = arrive, go                 # 차후 계산하기 편하게 뒤 바꿔주기
        for j in range(go//2, (arrive//2)+1):       # (go에 해당하는 복도번호)~ (arrive//2에 해당하는 복도번호)까지 구간 번호 새기기 위함
            hallway[j] += 1                         # 해당되는 복도의 각 구간에 +1해주기
    
    # 모두 들어가는데 걸리는 시간찾기
    max_second = 0                                  # 최대 걸리는 시간을 찾기 위한 변수
    for second in hallway:                          # hallway의 각 요소를 인자로해서 반복문
        if max_second < second:                     # max_second보다 hallway의 해당구간에 걸린 시간이 더 길다면
            max_second = second                     # max_second를 해당 hallway의 구간으로 변경
    print(f'#{testcase} {max_second}')               # 출력값 출력