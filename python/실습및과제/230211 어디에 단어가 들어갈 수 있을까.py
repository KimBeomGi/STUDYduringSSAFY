# [문제]
# N X N 크기의 단어 퍼즐을 만들려고 한다. 입력으로 단어 퍼즐의 모양이 주어진다.
# 주어진 퍼즐 모양에서 특정 길이 K를 갖는 단어가 들어갈 수 있는 자리의 수를 출력하는 프로그램을 작성하라.

# [예제]

# N = 5, K = 3 이고, 퍼즐의 모양이 아래 그림과 같이 주어졌을 때
# 길이가 3 인 단어가 들어갈 수 있는 자리는 2 곳(가로 1번, 가로 4번)이 된다.

# [제약 사항]

# 1. N은 5 이상 15 이하의 정수이다. (5 ≤ N ≤ 15)
# 2. K는 2 이상 N 이하의 정수이다. (2 ≤ K ≤ N)


# [입력]
# 입력은 첫 줄에 총 테스트 케이스의 개수 T가 온다.
# 다음 줄부터 각 테스트 케이스가 주어진다.
# 테스트 케이스의 첫 번째 줄에는 단어 퍼즐의 가로, 세로 길이 N 과, 단어의 길이 K 가 주어진다.
# 테스트 케이스의 두 번째 줄부터 퍼즐의 모양이 2차원 정보로 주어진다.
# 퍼즐의 각 셀 중, 흰색 부분은 1, 검은색 부분은 0 으로 주어진다.

# [출력]
# 테스트 케이스 t에 대한 결과는 “#t”을 찍고, 한 칸 띄고, 정답을 출력한다.
# (t는 테스트 케이스의 번호를 의미하며 1부터 시작한다.)

import sys
sys.stdin = open('230211 어디에 단어가 들어갈 수 있을까.txt', 'r')
'''
# [문제풀이]
# 0. 퍼즐에서 풀 수 있는 칸이 있다. 해당 칸의 길이가 각기 다른데, 주어지는 길이만큼의 칸이 몇 개 있는지 확인하는 문제이다.
# 0-1. 사용 가능한 칸은 1, 사용 불가능한 칸은 0으로 주어진다.
# 0-2. 5<=N<=15 by N 이고, 2<=K<=N길이의 칸을 구해야하며 이는 주어진다.
# 1. 우선 가로와 세로에서 각 사용가능한칸(흰색 즉 연속된 1)의 길이를 확인하고, 그 길이가 같다면 갯수를 +1 해주면 되는 문제 되겠다.ㄴ

T = int(input())
for testcase in range(1,T+1):
    N, K = map(int, input().split())                                # 퍼즐 크기 N, 찾을 칸길이 K를 입력받음
    matrix = [list(map(int, input().split())) for _ in range(N)]    # 주어진 입력값으로 퍼즐 초안(행렬)을 만듬
    count = 0                           # 총 K와 길이가 같은 녀석의 갯수을 확인 하기 위한 변수
    blank = 0                           # 각 칸의 길이를 확인하기 위한 변수
    count_list = []

    # 검사 시작
    # 가로검사
    for i in range(N):                  # i인자를 통해 N만큼의 반복, 열이나 행에 값을 넣기 위함
        for j in range(N):              # j인자를 통해 N만큼의 반복, 열이나 행에 값을 넣기 위함
            if matrix[i][j] == 1:       # 흰색칸에 맞아떨어지면
                blank += 1              # 각 칸의 길이에 +1
                if j == N-1 and blank == K:
                    count +=1
                    blank = 0
            elif matrix[i][j] == 0:     # 흰색칸에 맞아떨어지지 않으면, 검은색 칸이면
                if blank == K:          # 현재는 0이지만 이 직전까지 1이 K개인 칸이 발견되면 count+1
                    count +=1
                blank = 0               # 칸의 길이를 다시 세야하므로 blank는 0으로 돌려놔라
        # count_list.append(blank)
            # if blank == K:              # 검사를 하고나서 검사한 칸의 길이가 구하려는 칸의 길이와 동일하면
            #     count += 1              # count에 +1을 해라
            #     blank = 0               # 그리고 재검사 해야하니까 blank는 0으로 만들어라.
        # elif blank > K:             # 센 길이가 K보다 길어지면 그건 딱 맞아 떨어지는 칸이 아니니까
        #     count -=1               # count에서 -1
        blank = 0                       # 가로 한줄의 검사가 끝나면 칸도 끝나니까 칸 길이 검사 blank도 0
    
    # 세로검사
    for i in range(N):                  # i인자를 통해 N만큼의 반복, 열이나 행에 값을 넣기 위함
        for j in range(N):              # j인자를 통해 N만큼의 반복, 열이나 행에 값을 넣기 위함
            if matrix[j][i] == 1:       # 흰색칸에 맞아떨어지면
                blank += 1              # 각 칸의 길이에 +1
                if j == N-1 and blank == K:
                    count +=1
                    blank = 0
            elif matrix[j][i] == 0:     # 흰색칸에 맞아떨어지지 않으면, 검은색 칸이면
                if blank == K:          # 현재는 0이지만 이 직전까지 1이 K개인 칸이 발견되면 count+1
                    count +=1
                blank = 0               # 칸의 길이를 다시 세야하므로 blank는 0으로 돌려놔라
           
            # if blank == K:              # 검사를 하고나서 검사한 칸의 길이가 구하려는 칸의 길이와 동일하면
            #     count += 1              # count에 +1을 해라
            #     blank = 0               # 그리고 재검사 해야하니까 blank는 0으로 만들어라.
        # elif blank > K:             # 센 길이가 K보다 길어지면 그건 딱 맞아 떨어지는 칸이 아니니까
        #     count -=1               # count에서 -1
        blank = 0                       # 세로 한줄의 검사가 끝나면 칸도 끝나니까 칸 길이 검사 blank도 0
    print(f'#{testcase} {count}')
'''

# [문제풀이]
# 0. 퍼즐에서 풀 수 있는 칸이 있다. 해당 칸의 길이가 각기 다른데, 주어지는 길이만큼의 칸이 몇 개 있는지 확인하는 문제이다.
# 0-1. 사용 가능한 칸은 1, 사용 불가능한 칸은 0으로 주어진다.
# 0-2. 5<=N<=15 by N 이고, 2<=K<=N길이의 칸을 구해야하며 이는 주어진다.
# 1. 우선 가로와 세로에서 각 사용가능한칸(흰색 즉 연속된 1)의 길이를 확인하고, 그 길이가 같다면 갯수를 +1 해주면 되는 문제 되겠다.
# 2. 문제를 해결함에 있어 칸의갯수를 세아리면서 K와 칸의 갯수가 같으면 count +=1을 하려 했으나 K=4 인데 11111 의 경우에도 count가 +1되니 이 부분을 주의
# 2-1. 나는 여기서 2.를 해결하기 위해 2가지로 나눴는데 1번째는 마지막 열(행)에서 K와 동일한 칸의 갯수가 확인 되었을 때
# 2-2. 2번째는 마지막 열(행)이 아닌 경우로 나누어서 count 문제를 해결하였다.

T = int(input())
for testcase in range(1,T+1):
    N, K = map(int, input().split())                                # 퍼즐 크기 N, 찾을 칸길이 K를 입력받음
    matrix = [list(map(int, input().split())) for _ in range(N)]    # 주어진 입력값으로 퍼즐 초안(행렬)을 만듬
    count = 0                                   # 총 K와 길이가 같은 녀석의 갯수을 확인 하기 위한 변수
    blank = 0                                   # 각 칸의 길이를 확인하기 위한 변수

    # 검사 시작
    # 가로검사
    for i in range(N):                          # i인자를 통해 N만큼의 반복, 열이나 행에 값을 넣기 위함
        for j in range(N):                      # j인자를 통해 N만큼의 반복, 열이나 행에 값을 넣기 위함
            if matrix[i][j] == 1:               # 흰색칸에 맞아떨어지면
                blank += 1                      # 각 칸의 길이에 +1
                if j == N-1 and blank == K:     # j인자가 맨 마지막행의 인덱스 인자와 같고, 세아린 칸의 갯수가 K와 같다면
                    count +=1                   # count에 +1
                    blank = 0                   # 세아린 칸의 갯수는 0으로 만들기
            elif matrix[i][j] == 0:             # 흰색칸에 맞아떨어지지 않으면, 검은색 칸이면
                if blank == K:                  # 현재는 0이지만 이 직전까지 1이 K개인 칸이 발견되면 count+1
                    count +=1
                blank = 0                       # 칸의 길이를 다시 세야하므로 blank는 0으로 돌려놔라
        blank = 0                               # 가로 한줄의 검사가 끝나면 칸도 끝나니까 칸 길이 검사 blank도 0
    
    # 세로검사
    for i in range(N):                          # i인자를 통해 N만큼의 반복, 열이나 행에 값을 넣기 위함
        for j in range(N):                      # j인자를 통해 N만큼의 반복, 열이나 행에 값을 넣기 위함
            if matrix[j][i] == 1:               # 흰색칸에 맞아떨어지면
                blank += 1                      # 각 칸의 길이에 +1
                if j == N-1 and blank == K:     # j인자가 맨 마지막행의 인덱스 인자와 같고, 세아린 칸의 갯수가 K와 같다면
                    count +=1                   # count에 +1
                    blank = 0
            elif matrix[j][i] == 0:             # 흰색칸에 맞아떨어지지 않으면, 검은색 칸이면
                if blank == K:                  # 현재는 0이지만 이 직전까지 1이 K개인 칸이 발견되면 count+1
                    count +=1
                blank = 0                       # 칸의 길이를 다시 세야하므로 blank는 0으로 돌려놔라
        blank = 0                               # 세로 한줄의 검사가 끝나면 칸도 끝나니까 칸 길이 검사 blank도 0
    print(f'#{testcase} {count}')



'''
# 이하는 이전에 구상했던것

#[문제풀이]
# 0. N by N 의 퍼즐이 주어지는데 주어지는 K와 동일한 길이의 흰색구간을 찾아야한다.
# 0-1. 가로 세로로 확인이 가능하다. 가로로 3개가 연속된 3칸(초과는 x)이면 단어가 들어갈 수 있는 곳에 +1
# 0-2. 세로로 3개가 연속된 3칸(초과는 x)이면 단어가 들어갈 수 있는 곳에 +1
# 1.흰색부분은 1로 주어지고, 검은색 부분은 0으로 주어지므로 우선 연속 된 1의 갯수를 확인 먼저해보자.
# 1-1. 가로는 for i_list in list: for j in i_list로 리스트 안의 리스트에서 연속되는 1의 갯수로 확인
# 1-2. 세로는 for i in range(N): for j in range(N) list[j][i]로 찾아보자.
# 2. 구한 1을 이용해 K와 동일한지 비교 후 값 계산

T = int(input())
for testcase in range(1,T+1):
    N, K = map(int, input().split())    # N, K를 띄어쓰기로 구분해서 주어지므로 .split
    puzzle = [list(map(int, input().split())) for _ in range(N)]
    
    for row in puzzle:                  # 퍼즐의 한 행
        row_max_1 = []                  # 퍼즐의 한 행에서 흰색읜 연속되는 최대 길이를 담을 리스트
                                        # 이유는 행이 길어져서 2,3,5,4,6 뭐 이런 식으로 될 수도 있으니까
        is_row_max_1 = 0                # 한 행의 가장 긴 흰색길인지 확인을 위한 변수
        for i_row in puzzle:            # 퍼즐의 한 행의 인자
            if i_row == 1:              # 퍼즐의 한 행의 인자가 1(흰색)이면
                is_row_max_1 += 1       # iw_row_max_1에 + 1
            elif i_row != 1:
                row_max_1.append(is_row_max_1)
                is_row_max_1 = 0
            pass
'''