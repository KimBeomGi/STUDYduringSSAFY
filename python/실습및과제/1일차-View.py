# [문제]
# 강변에 빌딩들이 옆으로 빽빽하게 밀집한 지역이 있다.
# 이곳에서는 빌딩들이 너무 좌우로 밀집하여, 강에 대한 조망은 모든 세대에서 좋지만 왼쪽 또는 오른쪽 창문을 열었을 때 바로 앞에 옆 건물이 보이는 경우가 허다하였다.
# 그래서 이 지역에서는 왼쪽과 오른쪽으로 창문을 열었을 때, 양쪽 모두 거리 2 이상의 공간이 확보될 때 조망권이 확보된다고 말한다.
# 빌딩들에 대한 정보가 주어질 때, 조망권이 확보된 세대의 수를 반환하는 프로그램을 작성하시오.
# 아래와 같이 강변에 8채의 빌딩이 있을 때, 연두색으로 색칠된 여섯 세대에서는 좌우로 2칸 이상의 공백이 존재하므로 조망권이 확보된다. 따라서 답은 6이 된다.
# A와 B로 표시된 세대의 경우는 왼쪽 조망은 2칸 이상 확보가 되었지만 오른쪽 조망은 한 칸 밖에 확보가 되지 않으므로 조망권을 확보하지 못하였다.
# C의 경우는 반대로 오른쪽 조망은 2칸이 확보가 되었지만 왼쪽 조망이 한 칸 밖에 확보되지 않았다.
 
# [제약 사항]
# 가로 길이는 항상 1000이하로 주어진다.
# 맨 왼쪽 두 칸과 맨 오른쪽 두 칸에는 건물이 지어지지 않는다. (예시에서 빨간색 땅 부분)
# 각 빌딩의 높이는 최대 255이다.
 
# [입력]
# 총 10개의 테스트케이스가 주어진다.
# 각 테스트케이스의 첫 번째 줄에는 건물의 개수 N이 주어진다. (4 ≤ N ≤ 1000)
# 그 다음 줄에는 N개의 건물의 높이가 주어진다. (0 ≤ 각 건물의 높이 ≤ 255)
# 맨 왼쪽 두 칸과 맨 오른쪽 두 칸에 있는 건물은 항상 높이가 0이다. (예시에서 빨간색 땅 부분)
 
# [출력]
# #부호와 함께 테스트케이스의 번호를 출력하고, 공백 문자 후 조망권이 확보된 세대의 수를 출력한다.


# 입력
# 14
# 0 0 3 5 2 4 9 0 6 4 0 6 0 0
# 출력 6

# [문제풀이]
# 0. 예제를 숫자로 풀어내니, 가능한 경우는 대략 다음과 같다.
# 0 0 3 5 2 4 9 0 6 4 0 6 0 0
# (5-3, 5-0, 5-2, 5-4) -- (2,5,3,1) 작은값은 1
# (9-4, 9-2, 9-0, 9-6) -- (5,7,9,3) 작은값은 3
# (6-0, 6-4, 6-0, 6-0) -- (6,2,6,6) 작은값은 2

# 0-1. 테스트 케이스가 10개 주어지므로 T=10이며 for testcase in range(1,11): 을 작성해준다.
# 0-2. 건물갯수 N = int(input())으로 받아준다.
# 0-3. 각 위치마다의 건물의 개수는 띄어쓰기형식의 숫자로 입력받으므로 list(map(int, input().split()))으로 받아준다.

# 1. for 반복문을 이용해서 인덱스 iterable[2] ~ iterable[-2] 까지 가능하도록 해준다. 인덱스로 [0]~[10] 이라면 [2]~[8]만 이용한다.

# 2. 따라서 리스트[i]-리스트[i-1],리스트[i]-리스트[i-2],리스트[i]-리스트[i+1],리스트[i]-리스트[i+2] 구한다.
# 2-1. 1.을 튜플로 묶던지, 리스트로 묶어 준다. 1개만 이용할 것이 아니므로 빈 리스트 []를 하나 만들어 그 곳에 넣는다.
# 2-2. 그리고 2-1의 총 4개의 인덱스가 모두 양수인지 확인한다. 이때 음수 또는 0이 하나라도 있다면 해당 튜플은 제외한다.
# 2-3. 2-1이 모두 양수인지 확인되었다면, 총 4개의 값 중 가장 작은 값을 max함수를 이용하지 못하므로 for문을 이용해 구해준다.
# 3. 이때 for문을 이용해 첫 for문은 인덱스[0]~인덱스[-1]까지 더한 값인 총합변수를 하나 만들어주고,
# 3-1. 다음에 새로 for문을 생성해서, for문을 생성해서 if문을 생성해서 if 총합변수 > 인덱스값: 총합변수 = 인덱스값으로 제일 작은 값을 만들어준다.
# 4. 각 iterable마다 구해지는 최솟값을 합쳐줘야 하므로 1.을 생성하면서 all_good_house = 0을 만들어주고 그곳에 all_good_house = all_good_house + 최솟값을 해주도록하자.

for testcase in range(1,11):                                            # 테스트케이스 10회
    N = int(input())
    building = list(map(int, input().split()))                          # 입력값이 띄어쓰기 숫자형식이므로 리스트화하여 building에 대입
    all_good_house = 0

    for house in range(2,N-2):                                          # 처음의 0 0과 마지막의 0 0은 이용에 써먹기만하는 인덱스이므로 반복에서 제외
        solve1 = []                                                     # 각 위치의 건물(빌딩)당 조망권을 계산하기 위한 리스트
        solve1.append(building[house]-building[house-2])
        solve1.append(building[house]-building[house-1])
        solve1.append(building[house]-building[house+1])
        solve1.append(building[house]-building[house+2])

        for is_not_good in range(len(solve1)):                          # is_not_good 인자를 이용해 각 건물층고차를 기입한 solve1리스트의 각 인덱스가 모두 양수인지 판단
            if solve1[is_not_good] <= 0 :                               # solve1리스트의 각 인덱스 solve[is_not_good]이 음수라면
                solve1[is_not_good] = 0                                 # solve[is_not_good] 값을 0으로 둔다.

        min_num = 0                                                     # 차후 이용할 가장 작은 값을 넣을 min_num변수 생성  
        for i in solve1:                                                # i인자를 이용해 차후 가장 작은 값을 구하기 위해서 solve1의 총합
            min_num += i                                                # for 문으로 min_num을 우선 solve1에서 가장 큰 값으로 작성

        for good_house_num in solve1:                                   # 이용할 min_num을 만들어내기 위함, solve1에 하나라도 0 이 있다면 조망권이 보장되지 않는 것이기에 상관x
            if min_num > good_house_num:                                # min_num이 good_house_num보다 크면
                min_num = good_house_num                                # min_num이 good_house_num이 되게 해서 solve1의 최솟값을 구한다.
        
        all_good_house += min_num                                       # all_good_house에 조망권 좋은 집의 가구수를 추가
    print(f'#{testcase} {all_good_house}')