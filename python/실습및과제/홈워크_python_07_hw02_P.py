# [문제]
# 1937년 Collatz란 사람에 의해 제기된 이 추측은, 주어진 수가 1이 될때까지 다음 작업을 반복하면, 모든 수를 1로 만들 수 있다는 추측이다. 그 원리는 아래와 같다.

# 원리
#1. 입력된 수가 짝수라면 2로 나눈다.
#2. 입력된 수가 홀수라면 3을 곱하고 1을 더한다.
#3. 결과로 나온 수에 같은 작업을 1이 될 때까지 반복한다.

# 예를 들어, 입력된 수가 6이라면 6→3→10→5→16→8→4→2→1 이 되어 총 8번만에 1이된다.
# 위 작업을 몇 번이나 반복해야하는지 반환하는 함수 collatz()를 작성하시오
# 단, 작업을 500번을 반복해도 1이 되지 않는다면 -1을 반환하시오.

# [입력 및 출력예시]
# collatz(6)  # => 8
# collatz(16)  # => 4
# collatz(27)  # => 111
# collatz(626331)  # => -1

# [문제풀이]
#1. 함수 collatz()를 작성하라 했으므로 함수를 만들자.
#2. 반복문을 이용할텐데 이왕이면 for문을 이용한다. 이유는 500번이라느 한정이 있기때문에
#2-1. if 문을 작성해서 500번임에도 1이 아니라면 -1을 반환하게 하는 것이다.
#3. for문 안에서 if n % 2 == 0: n/2, if n%2 != 0: (n*3)+1을 반복시키자.
#4. 500번을 실행해도 1 이 아니면-1을 출력하도록 만드는 것도 포함시키자.

def collatz(num):
    for i in range(500):                        # 작업을 500번 반복하고 끝낼 것이기 때문.
        if num == 1:                            # num이 1이라면 작업횟수 i를 반환
            return i
        elif num != 1 and num % 2 == 0:         # num이 1이 아니고 짝수면 num = num/2
            num = num / 2
            if i == 499 and num != 1:           # 작업을 500번 완료 되었으므로
                return -1
            elif i == 499 and num == 1:         # 작업을 500번 돌리고 1이 되었다면 i를 출력
                return i
        elif num != 1 and num % 2 != 0:         # num이 1이 아니고 홀수면 num = (num*3) + 1
            num = (num * 3) + 1
            if i == 499 and num != 1:           # 작업을 500번 완료했으므로
                return -1
            elif i == 499 and num == 1:         # 작업을 500번 돌리고 1이 되었다면 i를 출력
                return i

print(collatz(6))  # => 8
print(collatz(16))  # => 4
print(collatz(27))  # => 111
print(collatz(626331))  # => -1