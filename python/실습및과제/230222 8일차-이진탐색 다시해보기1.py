

# 1부터 N까지의 자연수를 이진 탐색 트리에 저장하려고 한다.
# 이진 탐색 트리는 어떤 경우에도 저장된 값이 왼쪽 서브트리의 루트 <현재 노드 <오른쪽 서브 트리의 루트인 규칙을 만족한다.
# 추가나 삭제가 없는 경우에는, 완전 이진 트리가 되도록 만들면 효율적인 이진 탐색 트리를 만들수 있다.
# 다음은 1부터 6까지의 숫자를 완전 이진 트리 형태인 이진 탐색 트리에 저장한 경우이다.

# 완전 이진 트리의 노드 번호는 루트를 1번으로 하고 아래로 내려가면서 왼쪽에서 오른쪽 순으로 증가한다.
# N이 주어졌을 때 완전 이진 트리로 만든 이진 탐색 트리의 루트에 저장된 값과, N/2번 노드(N이 홀수인 경우 소수점 버림)에 저장된 값을 출력하는 프로그램을 만드시오.

# [입력]
# 첫 줄에 테스트케이스의 수 T가 주어진다. 1<=T<=50
# 다음 줄부터 테스트 케이스의 별로 N이 주어진다. 1<=N<=1000

# [출력]
# 각 줄마다 "#T" (T는 테스트 케이스 번호)를 출력한 뒤, 답을 출력한다.

import sys
sys.stdin = open('230222 8일차-이진탐색.txt','r')

# [문제풀이]
# 0. 1~ N까지의 자연수를 이진 탐색 트리에 저장. 왼쪽 서브에서 부터 중앙, 오른쪽 서브로 추가.
# 0-1. 루트에 저장된 값과 N/2번 노드(=N//2)에 저장된 값을 출력
# 1. 해당 문제는 값을 저장하는 것은 중위 순회로 값을 저장하며,
# 1-2. 번호를 매기는 것은 BFS?

def inorder(T):                     # T를 매개변수로 중위 순회하며 값을 집어넣을 함수
    global num                      # global에서 num을 사용
    if T > N:                       # T가 N보다 크게 되면 돌아가게 만드는 if문
        return
    
    # 자식노드는 왼쪽은 나*2, 오른쪽은 나*2 +1이기 때문에 아래의 형식이 나온다.
    inorder(T*2)                    # 중위 순회하면서 왼쪽 자식노드를 확인할 건데, 번호가 붙여있지 않으므로 T*2로 확인
    tree[T] = num                   # 각 노드가 확인되면 tree[T]즉 해당 번호의 노드에 값을 넣음.
    num+=1                          # 해당 번호의 노드에 값을 넣었다면 num+1을 해서 다음 노드에 값을 넣을 준비를 함    
    inorder((T*2)+1)                # 중위 순회하면서 오른쪽 자식노드를 확인할 건데, 번호가 붙여있지 않으므로 T*2+1로 확인



T = int(input())
for testcase in range(1,T+1):
    N = int(input())                # 노드의 갯수 N
    tree = [0]*(N+1)                # tree를 생성하는데 인덱스 값을 번호로 쓸것이고 1번부터 사용해서 N+1개임.
    num = 1                         # 함수에 이용될 num이자, 중위순회시 각 노드에 들어가게 될 값.
    inorder(1)                      # 1을 매개 변수로 함수 실행
    print(tree)
    print(f'#{testcase} {tree[1]} {tree[N//2]}')