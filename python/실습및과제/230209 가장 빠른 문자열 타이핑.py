# [문제]
# 어떤 문자열 A를 타이핑하려고 한다.
# 그냥 한 글자씩 타이핑 한다면 A의 길이만큼 키를 눌러야 할 것이다.
# 여기에 속도를 조금 더 높이기 위해 어떤 문자열 B가 저장되어 있어서 키를 한번 누른 것으로 B전체를 타이핑 할 수 있다.
# 이미 타이핑 한 문자를 지우는 것은 불가능하다.
# 예를 들어 A=”asakusa”, B=”sa”일 때, 다음 그림과 같이 B를 두 번 사용하면 5번 만에 A를 타이핑 할 수 있다.



# A와 B가 주어질 때 A 전체를 타이핑 하기 위해 키를 눌러야 하는 횟수의 최솟값을 구하여라.

# [입력]
# 첫 번째 줄에 테스트 케이스의 수 T가 주어진다.
# 각 테스트 케이스마다 첫 번째 줄에 두 문자열 A, B가 주어진다. A의 길이는 1이상 10,000이하, B의 길이는 1이상 100이하이다.

# [출력]
# 각 테스트 케이스마다 A 전체를 타이핑 하기 위해 키를 눌러야 하는 횟수의 최솟값을 출력한다.
'''
# [문제풀이]
# 0. abcabab라는 문자가 있을 때 aba가 만약 하나의 키로 작동할 수 있다면 'ab''c''ab''ab'로 총 4번만 타이핑하면 된다는 뜻의 문제다.
# 0-1. 1번째 입력 문자열에서 2번째 입력문자열을 대입했을 때, 1번재 문자를 몇 번 만 타이핑 하면 되는지 확인하는 문제다.
# 1. 입력값으로 banana bana가 있는데, bana를 넣으면 3번만 키를 입력하면된다. banana는 6번 입력인데 bana는 4번이므로 6-4+1을 해준다.
# 1-1. 위서 처럼 abcabab가 있다면 abc는 7글자인데 'ab' 2글자 를 넣으면 4번이다. 
# 1-2. 'ab'cabab는 6번으로 7-2+1=6, 'ab'c'ab'ab는 5번으로 6-2+1, 'ab'c'ab'ab'는 4번으로 5-2+1=4의 방식이 되겠다.

T = int(input())
for testcase in range(1,T+1):
    A, B = input().split()                  # 문자열과 '모듬키'로 A, B를 우선 받겠음.
    A_lenth = len(A)                        # 최초 A의 길이
    B_lenth = len(B)                        # 최초 B의 길이
    A_list = list(map(str, A))              # 문자열 A를 문자별 리스트화
    B_list = list(map(str, B))              # '모듬키' B를 문자별 리스트화
    # for i in range(A-B+1):                # 0~(A-B)까지만 실시
    
    i = 0                                   # while문을 사용하기 위한 i인자
    while i < (A_lenth-B_lenth+1):          # i 인자는 리스트[i]로 쓰일 거임.
    # 0~(A-B+1)까지만 실시 [0][1][2][3][4][5][6] 길이 7이 있는데, 모듬키 길이가 3이면, [0][1][2][3][4]의 5개만 가능하니까
        if A_list[i] == B_list[0]:          # A[i]가 B[0]의 값과 같다면
            is_yes = 0                      # '모듬키'와 일치하는 문자열의 부분인지 확인
            if B_lenth > 1:                 # B의 길이가 1 이상이면
                for e in range(1,B_lenth):      # 1~B의 길이만큼
                    if A_list[i+e] == B_list[e]:# '모듬키'가 제대로 문자열에 들어있다면
                        is_yes = 1              # '모듬키'와 일치하는 문자열의 부분임을 확인 완료
                    else:                       # i+e 와 같지 않다면
                        is_yes = 0              # '모듬키'와 불일치
                        i += 1                  # i에 +1 해서 다음 인덱스 확인
                        break                   # 중단!
            elif B_lenth == 1:              # B의 길이가 1 이라면
                is_yes = 1                  # '모듬키'와 if 이미 일치하므로 확인완료
                
            # i에 해당하는 인덱스 문자를 '모듬키'로 변경하고, 뒷 부분들은 삭제.
            if B_lenth > 1 and is_yes == 1: # B의 길이가 1 이상이면, i에 해당하는 위치에서 제대로 '모듬키'임을 확인했다면,
                A_list[i] = B               # 문자열 A[i]의 값을 '모듬키'로 바꾼다.
                # 이제 뒷부분들 삭제
                for j in range(1, B_lenth): # j를 인자로해서 1~ (B_lenth-1)까지
                    del A_list[i+j]         # '모듬키'로 바꾼 리스트[i]뒤의 '모듬키'와 겹치는 부분들 삭제
                A_lenth = len(A_list)       # 다시 A의 길이를 정의
                i += 1                      # 다음 인덱스를 확인하기 위해 i + 1
            elif B_lenth == 1 and is_yes == 1:   # B의 길이가 1 이고, '모듬키'ghkrdlsdl ehoTekaus,
                A_list[i] = B               # 문자열 A[i]의 값을 '모듬키'로 바꾼다.
                i += 1                      # 다음 인덱스를 확인하기 위해 i + 1
        else:                               # A[i]값과 B[0]의 값이 같지 않으면
            i+=1                            # i에 +1 하고 다음 A의 값 확인

    print(f'#{testcase} {A_lenth}')
'''

# [문제풀이]
# 1 기존 방법이 틀렸으므로 다른 방법을 시도
# 2. count 하는 방식으로 진행, 문자 1개 당 카운트, 만약 문자열이 '모듬키'와 일치하면 첫 카운트만 세도록 만들기.

T = int(input())
for testcase in range(1, T+1):
    A, B = map(str, input().split())    # 문자열 A, '모듬키'B 입력받음
    A_lenth = len(A)
    B_lenth = len(B)

    # while문 이용 '모듬키'로 확인 가능한 부분들 까지 확인 예로 0~19의 인덱스가 있을 때 길이3 모듬키면 0~17까지만 가능하므로. 해당 부분에 대해 확인
    count = 0                           # 카운트 생성 초기값 0
    i = 0                               # while문을 사용하기 위함.
    j = 0
    while i < (A_lenth-B_lenth+1):      # B의 길이에 따라 사용할 수 있는 A의 인덱스가 차이가 나므로
        if A[i] != B[j]:                # A[]의 문자와 B[]의 문자가 일치하지 않으면
            i +=1                       # 그냥 타이핑 1개로 쳐야하니까 다음값을 확인하러 가자.
            j = 0                       # j인자는 그대로
            count += 1                  # 그냥 타이핑 1개로 치자
        elif A[i] == B[j]:              # A[]의 문자와 B[]의 문자가 일치한다면?
            count += 1                  # 일단 타이핑 1개 침
            # for else 문 이용해보기
            for e in range(B_lenth):    # '모듬키'의 길이만큼 0~(B_lenth-1)를 e인자로 반복
                if A[i+e] != B[j+e]:    # 확인해보니 '모듬키가' 아니였다면
                    i += 1              # i를 1만큼 더해서 다음 A[]를 확인해보자.
                    break
            else:
                i += B_lenth            # i에 '모듬키'의 길이 만큼 더해줘서 다음 A[]를 확인하러 갈 수 있게 하자.
    
    # while문 이용 '모듬키'가 끼이면 확인 불가능 한 곳을 계산하기 위한 반복문
    while (A_lenth-B_lenth+1) <= i < A_lenth:   # '모듬키'를 확인 가능한 곳 이후 마지막 부분에 대한 것
        count +=1                       # 확인 가능한 i마다 count +1
        i += 1                          # 다음 A[]를 확인하기 위해 i +1
    print(f'#{testcase} {count}')


# 아래는 에러로 실패한 풀이법

# # [문제풀이]
# # 0. abcabab라는 문자가 있을 때 aba가 만약 하나의 키로 작동할 수 있다면 'ab''c''ab''ab'로 총 4번만 타이핑하면 된다는 뜻의 문제다.
# # 0-1. 1번째 입력 문자열에서 2번째 입력문자열을 대입했을 때, 1번재 문자를 몇 번 만 타이핑 하면 되는지 확인하는 문제다.
# # 1. 입력값으로 banana bana가 있는데, bana를 넣으면 3번만 키를 입력하면된다. banana는 6번 입력인데 bana는 4번이므로 6-4+1을 해준다.
# # 1-1. 위서 처럼 abcabab가 있다면 abc는 7글자인데 'ab' 2글자 를 넣으면 4번이다. 
# # 1-2. 'ab'cabab는 6번으로 7-2+1=6, 'ab'c'ab'ab는 5번으로 6-2+1, 'ab'c'ab'ab'는 4번으로 5-2+1=4의 방식이 되겠다.

# T = int(input())
# for testcase in range(1,T+1):
#     A, B = input().split()                  # 문자열과 '모듬키'로 A, B를 우선 받겠음.
#     A_lenth = len(A)                        # 최초 A의 길이
#     B_lenth = len(B)                        # 최초 B의 길이
#     A_list = list(map(str, A))              # 문자열 A를 문자별 리스트화
#     B_list = list(map(str, B))              # '모듬키' B를 문자별 리스트화
#     # for i in range(A-B+1):                # 0~(A-B)까지만 실시
    
#     i = 0                                   # while문을 사용하기 위한 i인자
#     while i < (A_lenth-B_lenth+1):          # i 인자는 리스트[i]로 쓰일 거임.
#     # 0~(A-B+1)까지만 실시 [0][1][2][3][4][5][6] 길이 7이 있는데, 모듬키 길이가 3이면, [0][1][2][3][4]의 5개만 가능하니까
#         if A_list[i] == B_list[0]:          # A[i]가 B[0]의 값과 같다면
#             is_yes = 0                      # '모듬키'와 일치하는 문자열의 부분인지 확인
#             if B_lenth > 1:                 # B의 길이가 1 이상이면
#                 for e in range(1,B_lenth):      # 1~B의 길이만큼
#                     if A_list[i+e] == B_list[e]:# '모듬키'가 제대로 문자열에 들어있다면
#                         is_yes = 1              # '모듬키'와 일치하는 문자열의 부분임을 확인 완료
#                     else:                       # i+e 와 같지 않다면
#                         is_yes = 0              # '모듬키'와 불일치
#                         i += 1                  # i에 +1 해서 다음 인덱스 확인
#                         break                   # 중단!
#             elif B_lenth == 1:              # B의 길이가 1 이라면
#                 is_yes = 1                  # '모듬키'와 if 이미 일치하므로 확인완료
                
#             # i에 해당하는 인덱스 문자를 '모듬키'로 변경하고, 뒷 부분들은 삭제.
#             if B_lenth > 1 and is_yes == 1: # B의 길이가 1 이상이면, i에 해당하는 위치에서 제대로 '모듬키'임을 확인했다면,
#                 A_list[i] = B               # 문자열 A[i]의 값을 '모듬키'로 바꾼다.
#                 # 이제 뒷부분들 삭제
#                 for j in range(1, B_lenth): # j를 인자로해서 1~ (B_lenth-1)까지
#                     del A_list[i+j]         # '모듬키'로 바꾼 리스트[i]뒤의 '모듬키'와 겹치는 부분들 삭제
#                 A_lenth = len(A_list)       # 다시 A의 길이를 정의
#                 i += 1                      # 다음 인덱스를 확인하기 위해 i + 1
#             elif B_lenth == 1 and is_yes == 1:   # B의 길이가 1 이고, '모듬키'ghkrdlsdl ehoTekaus,
#                 A_list[i] = B               # 문자열 A[i]의 값을 '모듬키'로 바꾼다.
#                 i += 1                      # 다음 인덱스를 확인하기 위해 i + 1
#         else:                               # A[i]값과 B[0]의 값이 같지 않으면
#             i+=1                            # i에 +1 하고 다음 A의 값 확인

#     print(f'#{testcase} {A_lenth}')