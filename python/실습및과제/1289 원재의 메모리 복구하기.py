# # [문제]
# 원재가 컴퓨터를 만지다가 실수를 저지르고 말았다. 메모리가 초기화된 것이다.
# 다행히 원래 메모리가 무슨 값이었는지 알고 있었던 원재는 바로 원래 값으로 되돌리려고 했으나 메모리 값을 바꿀 때 또 문제가 생겼다.
# 메모리 bit중 하나를 골라 0인지 1인지 결정하면 해당 값이 메모리의 끝까지 덮어씌우는 것이다.
# 예를 들어 지금 메모리 값이 0100이고, 3번째 bit를 골라 1로 설정하면 0111이 된다.
# 원래 상태가 주어질 때 초기화 상태 (모든 bit가 0) 에서 원래 상태로 돌아가는데 최소 몇 번이나 고쳐야 하는지 계산해보자.

# [입력]
# 첫 번째 줄에 테스트 케이스의 수 T가 주어진다.
# 각 테스트 케이스는 한 줄로 이루어져 있으며, 메모리의 원래 값이 주어진다.
# 메모리의 길이는 1이상 50이하이다.

# [출력]
# 각 테스트 케이스마다 ‘#x’(x는 테스트케이스 번호를 의미하며 1부터 시작한다)를 출력하고,
# 초기값(모든bit가 0)에서 원래 값으로 복구하기 위한 최소 수정 횟수를 출력한다.

import sys
sys.stdin =  open('1289 원재의 메모리 복구하기.txt', 'r')
# [문제풀이]
# 0. 주어지는 값은 원래 메모리 값이다.
# 0-1. 0100을 만들고싶다면 문제에서는 하나의 값이 주어지면 0000 이면 2번째 값에 1을 넣으면 0111 이 되고, 여기에 3번째에 0을 넣어 0100을 만드는 것이다.
# 1. 위 방식으로 만드는 것을 실행해보자.

T = int(input())
for testcase in range(1, T+1):
    initial_A = list(map(int,input()))          # 원래 메모리를 리스트로 각각 받음
    N = len(initial_A)                          # 원래 메모리의 길이
    # solve = [0]*N
    count = 0                                   # 몇 번 수행해야 원래 메모리가 되는지 기록하는 count
    for i in range(N):                          # 첫 시작 1 를 찾아냄.
        if initial_A[i] == 1:                   # 1이 발견되면
            count += 1                          # count에 +1을 해주고
            for j in range(i+1, N):             # 첫 시작인 i+1부터 다시 검사
                if initial_A[j-1] == 1 and initial_A[j] == 0:       # 이전값이 1이고 내가 0이면 작업을 한 것이니까
                    count += 1                                      # count 추가
                elif initial_A[j-1] == 0 and initial_A[j] == 1:     # 이전값이 0이고 내가 1이면 작업을 한 것이니까
                    count += 1                                      # count 추가
            break                               # 첫 시작 1을 발견한 뒤에 모든 일을 끝냈으니 그만.
    print(f'#{testcase} {count}')