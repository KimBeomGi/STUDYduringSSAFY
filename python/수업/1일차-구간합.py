# [문제]
# N개의 정수가 들어있는 배열에서 이웃한 M개의 합을 계산하는 것은 디지털 필터링의 기초연산이다.
# M개의 합이 가장 큰 경우와 가장 작은 경우의 차이를 출력하는 프로그램을 작성하시오.
# 다음은 N=5, M=3이고 5개의 숫자 1 2 3 4 5가 배열 v에 들어있는 경우이다.
# [1 2 3 4 5]
# 이웃한 M개의 합이 가장 작은 경우 1 + 2 + 3 = 6
# [1 2 3 4 5]
# 1 2 3 만 표시되어있음
# 이웃한 M개의 합이 가장 큰 경우 3 + 4 + 5 = 12
# [1 2 3 4 5]
# 3 4 5 만 표시되어있음
# 답은 12와 6의 차인 6을 출력한다.

# [입력]
# 첫 줄에 테스트 케이스 개수 T가 주어진다.  ( 1 ≤ T ≤ 50 )
# 다음 줄부터 테스트케이스의 첫 줄에 정수의 개수 N과 구간의 개수 M 주어진다. ( 10 ≤ N ≤ 100,  2 ≤ M ＜ N )
# 다음 줄에 N개의 정수 ai가 주어진다. ( 1 ≤ a ≤ 10000 )

# [출력]
# 각 줄마다 "#T" (T는 테스트 케이스 번호)를 출력한 뒤, 답을 출력한다.

# [입력]
# 3
# 10 3
# 1 2 3 4 5 6 7 8 9 10
# 10 5
# 6262 6004 1801 7660 7919 1280 525 9798 5134 1821
# 20 19
# 3266 9419 3087 9001 9321 1341 7379 6236 5795 8910 2990 2152 2249 4059 1394 6871 4911 3648 1969 2176

# [출력]
# #1 21
# #2 11088
# #3 1090

# [문제풀이]
# 1. 테스트케이스 T입력먼저받고, 1~T만큼 반복문을 돌린다.
# 1-1. 정수의 개수 N개, 구간의 개수 M개를 띄어쓰기 구분으로 입력받는다. N, M = map(int, input().split())
# 1-2. N개의 정수 ai가 주어지는데 이것이 띄어쓰기로 구분되어 입력되며 모두 숫자로 입력된다.
# 1-3. 따라서 ai를 입력받을 때 이것을 향후 이용하기 좋게 쓰기 위해 list(map(int, input().split()))으로 받는다.
# 2. for 반복문을 이용해서 만든 리스트의 길이인 range(N-M)
# 2-1. N=10, M=3 이라면 리스트[i]+리스트[i+1]+리스트[i+2]가 되도록 만들도록 작성
# 2-2. 위 2-1의 값을 넣어둘 max_sum과 min_sum을 만들어두고
# 2-3. if문을 활용해서 max_sum<~ 라면 max_sum = max, min_sum<~ 라면 min_sum = ~이 되게 한다.
# 3. dif_value = max_sum - min_sum라는 변수를 할당
# 3-1. f스트링을 이용해서 print(f'#{testcase} {dif_value}')을 출력한다.

T = int(input())
for testcase in range(1, T+1):                          # testcase를 인자로해 1~T만큼 반복실행
    N, M = map(int, input().split())                    # N, M을 각각 입력받음
    ais = list(map(int, input().split()))               # 띄어쓰기 구분 숫자 입력값이므로 ai를 넣어둘 ais라는 리스트를 생성
    max_sum = 0                                         # 구간합 중 가장 큰 값을 넣을 max_sum 변수
    min_sum = 0                                         # 구간합 중 가장 작은 값을 넣을 min_sum 변수
    for ai in ais:                                      # min_sum의 값을 우선 ais리스트내 모든 값을 더한 값으로 설정.
        min_sum = min_sum + ai

    for i in range(N-M+1):                              # i를 인자로해 구간합을 구할수 있는 만큼의 반복을 실행
                                                        # 리스트의 길이인 N과 구간갯수인 M을 그대로 빼면 마지막 리스트[-3]+리스트[-2]+리스트[-1]에 대해선 행동하지 못하기에 +1
        solve_sum = ais[i]                              # ais[i]+ais[i+1]---+ais[i+]

        for j in range(1, M):                           # j를 인자로 하여 1 ~ M-1까지 반복실행 하면서 slove_sum에 ais[i+j]더하기 위한 반복문
            solve_sum = solve_sum + ais[i+j]            # i를 인자로 한 반복문에서의 첫 값에 이어지는 [i+1],[i+2],[i+3]과 같은 값을 각각 더해줌
        if max_sum < solve_sum:                         # 구간합 최댓값 max_sum이 새로나온 구간합 solve_sum보다 작다면
            max_sum = solve_sum                         # max_sum에 solve_sum의 값을 대입해라.
        if min_sum > solve_sum:                         # 구간합 최솟값 min_sum이 새로나온 구간합 solve_sum보다 크다면
            min_sum = solve_sum                         # min_sum에 solve_sum의 값을 대입해라.

    dif_value = max_sum-min_sum                         # dif_value변수에 구간합 최댓값 - 구간합 최솟값을 할당
    print(f'#{testcase} {dif_value}')                   # test케이스와 같이 구한 값 출력