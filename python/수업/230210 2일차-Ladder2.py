# [문제]
# 점심 시간에 산책을 다니는 사원들은 최근 날씨가 더워져, 사다리 게임을 통하여 누가 아이스크림을 구입할지 결정하기로 한다.
# 김 대리는 사다리타기에 참여하지 않는 대신 사다리를 그리기로 하였다.
# 사다리를 다 그리고 보니 김 대리는 어느 사다리를 고르면 최단거리로 바닥에 도착하게 되는지 궁금해졌다. 이를 구해보자.
# 아래 <그림 1>의 예를 살펴보면, 출발점 x=0 및 x=9인 세로 방향의 두 막대 사이에 임의의 개수의 막대들이 랜덤 간격으로 추가되고(이 예에서는 2개가 추가됨) 이 막대들 사이에 가로 방향의 선들이 또한 랜덤하게 연결된다.
# X=0인 출발점에서 출발하는 사례에 대해서 화살표로 표시한 바와 같이, 아래 방향으로 진행하면서 좌우 방향으로 이동 가능한 통로가 나타나면 방향 전환을 하게 된다.
# 방향 전환 이후엔 다시 아래 방향으로만 이동하게 되며, 바닥에 도착하면 멈추게 된다.
# 최단거리로 바닥에 도착하려면 X=4인 출발점에서 출발해야 하므로 답은 4가 된다. 해당 경로는 별도로 표시하였다.

# 아래 <그림 2>와 같은 100 x 100 크기의 2차원 배열로 주어진 사다리에 대해서, 
# 모든 출발점을 검사하여 바닥까지 가장 짧은 이동 거리를 갖는 시작점 x(복수 개인 경우 가장 큰 x좌표)를 반환하는 코드를 작성하라.
# (‘0’으로 채워진 평면상에 사다리는 연속된 ‘1’로 표현된다.)

# [제약사항]
# 한 막대에서 출발한 가로선이 다른 막대를 가로질러서 연속하여 이어지는 경우는 없다.

# [입력]
# 각 테스트 케이스의 첫 번째 줄에는 테스트 케이스의 번호가 주어지며, 바로 다음 줄에 테스트 케이스가 주어진다.
# 총 10개의 테스트 케이스가 주어진다.

# [출력]
# #부호와 함께 테스트 케이스의 번호를 출력하고, 공백 문자 후 도착하게 되는 출발점의 x좌표를 출력한다.

import sys
sys.stdin = open('230210 2일차-Ladder2.txt.', 'r')

# [문제풀이]
#0. 총 100 by 100으로 이루어진 행렬에서 사다리가 이루어져있다.
#0-1. 사다리는 1로 표현되어 있으며, 각 출발점에서 마지막에 도착했을 때 가장 짧은 사다리 라인을 찾는 것이다.
#0-2. 만일 같은 길이의 사다리 라인이 있다면 제일 오른쪽 그러니까 리스트[i]로 치면 더 큰 i를 출력해야 된다.
#1. 왼쪽 오른쪽 아래를 각각 구상하며, for 문으로는 사다리를 타는데 제한이 있다 판단. 따라서 while문 이용
#2. 사다리 맨 왼쪽과 사다리 맨 오른쪽의 경우. 복합적인 문제가 발생할 수 있으므로 사전 차단
#3. 최소 이동거리를 기록할 값, 해당 시작점을 기록할 변수와 한 번의 반복에서 이동거리와 시작 지점을 기록할 변수가 필요

T = 10
for testcase in range(1, T+1):                                              # 테스트케이스 만큼 반복
    testcase = int(input())                                                 # 테스트케이스를 한 번 더 주니까
    ladder = [list(map(int, input().split())) for _ in range(100)]          # 100 by 100이므로 100개의 행을 받음
    
    # 사다리 돌리기
    min_count = 100*100                                     # 사다리 라인중 이동거리가 제일 짧은 길이를 재기 위함, 100*100을 한 이유는 행을 다 거쳐야 100*100이므로 제일 큰수라서.
    min_count_start = 0                                     # 제일 이동거리가 짧은 지점
    for start in range(100):                                  # 0~9까지 출발지점
        count = 0                                           # 사다리 라인의 이동거리를 세기 위함
        
        # 사다리 시작
        if ladder[0][start] == 1:                           # 첫 행에서 시작하기 위해서.
            i = 0                                           # 행을 나타내는 인자 i 맨 위부터 시작하기 위함
            j = start                                       # 열을 나타내는 인자 j 위 for문에서 주어진 시작지점에서 시작
            while 0 <= i <= 99 and 0 <= j <= 99:            # 범위내의 행과 열에서 작동할 수 있도록 하기
                if i == 99:                                 # 행의 끝에 도착했으면
                    break                                   # 사다리 멈춰!
                
                #왼쪽만났을때, 그리고 왼쪽 끝까지가서 밑에 라인이 있을 수 있을 때
                elif j > 0 and ladder[i][j-1] == 1:         # 사다리 왼쪽에 라인이 있으면, 그리고 열이 맨 왼쪽 열이 아니라면
                    # while j > 0 and ladder[i][j-1] == 1:    # 왼쪽으로 갔으니 주우욱 가야지.
                    while True:    # 이것도 가능하네????
                        j -= 1                              # 왼쪽으로 한칸
                        count += 1                          # 이동거리 +1
                        if i < 99 and ladder[i+1][j] == 1:  # 왼쪽으로 가는 중에 아래에 사다리가 있으면, 그리고 맨 아래 행이 아니면
                            i += 1                          # 아래로 +1
                            count += 1                      # 이동거리 +1
                            break                           # 멈춰!
                
                #오른쪽만났을때, 그리고 오른쪽 끝까지가서 밑에 라인이 있을 수 있을 때
                elif j < 99 and ladder[i][j+1] == 1:        # 사다리 왼쪽에 라인이 있으면, 그리고 열이 맨 오른쪽 열이 아니라면
                    # while j < 99 and ladder[i][j+1] == 1:   # 오른쪽으로 갔으니 주우욱 가야지.
                    while True:   # 이것도 가능하네????
                        j += 1                              # 왼쪽으로 한칸
                        count += 1                          # 이동거리 +1
                        if i < 99 and ladder[i+1][j] == 1:  # 오른쪽으로 가는 중에 아래에 사다리가 있으면, 그리고 맨 아래 행이 아니면
                            i += 1                          # 아래로 +1
                            count += 1                      # 이동거리 +1
                            break                           # 멈춰!
                #아래쪽을 만났을때
                elif i < 99 and ladder[i+1][j] == 1:        # 사다리 아래에 라인이 있으면, 그리고 맨 아래 행이 아니면
                    i += 1                                  # 아래로 +1
                    count += 1                              # 이동거리에 +1
        
        # min_count와 출발지점 찾기
        if count > 0 and min_count >= count:                # 이동거리가 최소 이동거리와 같다면
            min_count = count                               # mincount에 현재 구한 count를 대입
            min_count_start = start                         # 기존의 min_count출발지점 대신 현재의 출발지를 대입
    print(f'#{testcase} {min_count_start}')